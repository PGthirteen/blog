(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{575:function(e,s,t){"use strict";t.r(s);var v=t(0),_=Object(v.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"hooks与事件绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hooks与事件绑定"}},[e._v("#")]),e._v(" Hooks与事件绑定")]),e._v(" "),s("p",[e._v("在"),s("code",[e._v("React")]),e._v("中，我们经常需要为组件添加事件处理函数，例如处理表单提交、处理点击事件等。通常情况下，我们需要在类组件中使用"),s("code",[e._v("this")]),e._v("关键字来绑定事件处理函数的上下文，以便在函数中使用组件的实例属性和方法。"),s("code",[e._v("React Hooks")]),e._v("是"),s("code",[e._v("React 16.8")]),e._v("引入的一个新特性，其出现让"),s("code",[e._v("React")]),e._v("的函数组件也能够拥有状态和生命周期方法。"),s("code",[e._v("Hooks")]),e._v("的优势在于可以让我们在不编写类组件的情况下，复用状态逻辑和副作用代码，"),s("code",[e._v("Hooks")]),e._v("的一个常见用途是处理事件绑定。")]),e._v(" "),s("h2",{attrs:{id:"描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[e._v("#")]),e._v(" 描述")]),e._v(" "),s("p",[e._v("在"),s("code",[e._v("React")]),e._v("中使用类组件时，我们可能会被大量的"),s("code",[e._v("this")]),e._v("所困扰，例如"),s("code",[e._v("this.props")]),e._v("、"),s("code",[e._v("this.state")]),e._v("以及调用类中的函数等。此外，在定义事件处理函数时，通常需要使用"),s("code",[e._v("bind")]),e._v("方法来绑定函数的上下文，以确保在函数中可以正确地访问组件实例的属性和方法，虽然我们可以使用箭头函数来减少"),s("code",[e._v("bind")]),e._v("，但是还是使用"),s("code",[e._v("this")]),e._v("语法还是没跑了。")]),e._v(" "),s("p",[e._v("那么在使用"),s("code",[e._v("Hooks")]),e._v("的时候，可以避免使用类组件中的"),s("code",[e._v("this")]),e._v("关键字，因为"),s("code",[e._v("Hooks")]),e._v("是以函数的形式来组织组件逻辑的，我们通常只需要定义一个普通函数组件，并在函数组件中使用"),s("code",[e._v("useState")]),e._v("、"),s("code",[e._v("useEffect")]),e._v("等"),s("code",[e._v("Hooks")]),e._v("来管理组件状态和副作用，在处理事件绑定的时候，我们也只需要将定义的事件处理函数传入"),s("code",[e._v("JSX")]),e._v("就好了，也不需要"),s("code",[e._v("this")]),e._v("也不需要"),s("code",[e._v("bind")]),e._v("。")]),e._v(" "),s("p",[e._v("那么问题来了，这个问题真的这么简单吗，我们经常会听到类似于"),s("code",[e._v("Hooks")]),e._v("的心智负担很重的问题，从我们当前要讨论的事件绑定的角度上，那么心智负担就主要表现在"),s("code",[e._v("useEffect")]),e._v("和"),s("code",[e._v("useCallback")]),e._v("以及依赖数组上。其实类比来看，类组件类似于引入了"),s("code",[e._v("this")]),e._v("和"),s("code",[e._v("bind")]),e._v("的心智负担，而"),s("code",[e._v("Hooks")]),e._v("解决了类组件的心智负担，又引入了新的心智负担，但是其实换个角度来看，所谓的心智负担也只是需要接受的新知识而已，我们需要了解"),s("code",[e._v("React")]),e._v("推出新的设计，新的组件模型，当我们掌握了之后那就不会再被称为心智负担了，而应该叫做语法，当然其实叫做负担也不是没有道理的，因为很容易在不小心的情况下出现隐患。那么接下来我们就来讨论下"),s("code",[e._v("Hooks")]),e._v("与事件绑定的相关问题，所有示例代码都在"),s("code",[e._v("https://codesandbox.io/s/react-ts-template-forked-z8o7sv")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"每日一题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#每日一题"}},[e._v("#")]),e._v(" 每日一题")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("https://github.com/WindrunnerMax/EveryDay\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("https://juejin.cn/post/7194368992025247804\nhttps://juejin.cn/post/7098137024204374030\nhttps://react.dev/reference/react/useCallback\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])])])}),[],!1,null,null,null);s.default=_.exports}}]);