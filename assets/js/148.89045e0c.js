(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{592:function(e,s,a){"use strict";a.r(s);var n=a(0),t=Object(n.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"usememo与usecallback"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usememo与usecallback"}},[e._v("#")]),e._v(" useMemo与useCallback")]),e._v(" "),s("p",[s("code",[e._v("useMemo")]),e._v("和"),s("code",[e._v("useCallback")]),e._v("都可缓存函数的引用或值，从更细的角度来说"),s("code",[e._v("useMemo")]),e._v("则返回一个缓存的值，"),s("code",[e._v("useCallback")]),e._v("是返回一个缓存函数的引用。")]),e._v(" "),s("h2",{attrs:{id:"usememo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[e._v("#")]),e._v(" useMemo")]),e._v(" "),s("p",[s("code",[e._v("useMemo")]),e._v("的"),s("code",[e._v("TS")]),e._v("定义可以看出，范型"),s("code",[e._v("T")]),e._v("在"),s("code",[e._v("useMemo")]),e._v("中是一个返回的值类型。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type DependencyList = ReadonlyArray<any>;\n\nfunction useMemo<T>(factory: () => T, deps: DependencyList | undefined): T;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("下面是"),s("code",[e._v("useMemo")]),e._v("的简单示例，在"),s("code",[e._v("a")]),e._v("和"),s("code",[e._v("b")]),e._v("的变量值不变的情况下，"),s("code",[e._v("memoizedValue")]),e._v("的值不变，在此时"),s("code",[e._v("useMemo")]),e._v("函数的第一个参数也就是"),s("code",[e._v("computeExpensiveValue")]),e._v("函数不会被执行，从而达到节省计算量的目的。")]),e._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" memoizedValue "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("useMemo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("computeExpensiveValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("把创建函数"),s("code",[e._v("factory: () => T")]),e._v("和依赖项数组"),s("code",[e._v("deps: DependencyList | undefined")]),e._v("作为参数传入 "),s("code",[e._v("useMemo")]),e._v("，它仅会在某个依赖项改变时才重新计算"),s("code",[e._v("memoized")]),e._v(" 值，这种优化有助于避免在每次渲染时都进行高开销的计算，例如上文的"),s("code",[e._v("computeExpensiveValue")]),e._v("是需要一个大量计算的函数时，"),s("code",[e._v("useMemo")]),e._v("有助于减少性能开销，以防止"),s("code",[e._v("Js")]),e._v("太多次长时间运行计算导致页面无响应。"),s("br"),e._v("\n此外，传入"),s("code",[e._v("useMemo")]),e._v("的函数会在渲染期间执行，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于"),s("code",[e._v("useEffect")]),e._v("的适用范畴，而不是"),s("code",[e._v("useMemo")]),e._v("。如果没有提供依赖项数组，"),s("code",[e._v("useMemo")]),e._v("在每次渲染时都会计算新的值。"),s("br"),e._v(" "),s("code",[e._v("eslint")]),e._v("的"),s("code",[e._v("eslint-plugin-react-hooks")]),e._v("中的"),s("code",[e._v("exhaustive-deps")]),e._v("规则可以在添加错误依赖时发出警告并给出修复建议。"),s("br"),e._v("\n相比较于"),s("code",[e._v("useEffect")]),e._v("看起来和"),s("code",[e._v("Vue")]),e._v("的"),s("code",[e._v("Watch")]),e._v("很像，但是思想方面是不同的，"),s("code",[e._v("Vue")]),e._v("是监听值的变化而"),s("code",[e._v("React")]),e._v("是用以处理副作用。在"),s("code",[e._v("useMemo")]),e._v("方面就和"),s("code",[e._v("Vue")]),e._v("的"),s("code",[e._v("computed")]),e._v("非常类似了，同样都属于缓存依赖项的计算结果，当然在实现上是完全不同的。")]),e._v(" "),s("h2",{attrs:{id:"usecallback"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[e._v("#")]),e._v(" useCallback")]),e._v(" "),s("p",[s("code",[e._v("useCallback")]),e._v("的"),s("code",[e._v("TS")]),e._v("定义可以看出，范型"),s("code",[e._v("T")]),e._v("在"),s("code",[e._v("useCallback")]),e._v("中是一个返回的函数类型。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type DependencyList = ReadonlyArray<any>;\n\nfunction useCallback<T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("下面是"),s("code",[e._v("useCallback")]),e._v("的简单示例，在"),s("code",[e._v("a")]),e._v("和"),s("code",[e._v("b")]),e._v("的变量值不变的情况下，"),s("code",[e._v("memoizedCallback")]),e._v("的函数引用不变，在此时"),s("code",[e._v("useCallback")]),e._v("函数的第一个参数不会被重新定义，即引用的依旧是原函数，从而达到性能优化的目的。")]),e._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" memoizedCallback "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("useCallback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("doSomething")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("把内联回调函数"),s("code",[e._v("callback: T")]),e._v("及依赖项数组"),s("code",[e._v("deps: DependencyList")]),e._v("作为参数传入 "),s("code",[e._v("useCallback")]),e._v("，它将返回该回调函数的"),s("code",[e._v("memoized")]),e._v("版本，该回调函数仅在某个依赖项改变时才会更新，将回调函数传递给经过优化的并使用引用相等性去避免非必要渲染(例如"),s("code",[e._v("shouldComponentUpdate")]),e._v(")的子组件时，它将非常有用。此外，"),s("code",[e._v("useCallback(fn, deps)")]),e._v("相当于"),s("code",[e._v("useMemo(() => fn, deps)")]),e._v("，由此"),s("code",[e._v("useCallback")]),e._v("可以看作"),s("code",[e._v("useMemo")]),e._v("的语法糖。"),s("br"),e._v(" "),s("code",[e._v("eslint")]),e._v("的"),s("code",[e._v("eslint-plugin-react-hooks")]),e._v("中的"),s("code",[e._v("exhaustive-deps")]),e._v("规则可以在添加错误依赖时发出警告并给出修复建议。"),s("br"),e._v("\n在"),s("code",[e._v("useCallback")]),e._v("的应用方面，在这里引用一下 @松松 给出的例子，一般"),s("code",[e._v("Js")]),e._v("上创建一个函数需要的时间并不至于要缓存的程度，那为什么要专门给缓存函数的创建做一个语法糖呢，这就跟"),s("code",[e._v("React.memo")]),e._v("有关系了。"),s("code",[e._v("React.memo")]),e._v("的默认第二参数是浅对比"),s("code",[e._v("shallow compare")]),e._v("上次渲染的"),s("code",[e._v("props")]),e._v("和这次渲染的"),s("code",[e._v("props")]),e._v("，如果你的组件的"),s("code",[e._v("props")]),e._v("中包含一个回调函数，并且这个函数是在父组件渲染的过程中创建的(见下例)，那么每次父组件(下例中的"),s("code",[e._v("<MyComponent />")]),e._v("）渲染时，"),s("code",[e._v("React")]),e._v("是认为你的子组件(下例中的"),s("code",[e._v("<Button />")]),e._v(")"),s("code",[e._v("props")]),e._v("是有变化的，不管你是否对这个子组件用了"),s("code",[e._v("React.memo")]),e._v("，都无法阻止重复渲染。这时就只能用"),s("code",[e._v("useCallback")]),e._v("来缓存这个回调函数，才会让"),s("code",[e._v("React")]),e._v("(或者说"),s("code",[e._v("Js")]),e._v(")认为这个"),s("code",[e._v("prop")]),e._v("和上次是相同的。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 下面三种方法都会在MyComponent渲染的过程中重新创建这个回调函数\n// 这样都会引起Button的重新渲染 因为Button的props变化了\nfunction MyComponent() {\n  return <Button onClick={() => doWhatever()} />;\n}\n\nfunction MyComponent() {\n  const handleClick = () => doWhatever();\n  return <Button onClick={handleClick} />;\n}\n\nfunction MyComponent() {\n  function handleClick(){ \n    doWhatever();\n  }\n  return <Button onClick={handleClick} />;\n}\n\n// 只有使用useCallback， 才会导致即使MyComponent渲染，也不重新创建一个新的回调函数\n// 这样就不会引发Button的重新渲染 因为Button的props没变\nfunction MyComponent() {\n  const handleClick = React.useCallBack(() => doWhatever(), []);\n  return <Button onClick={handleClick} />;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br")])]),s("h2",{attrs:{id:"最后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[e._v("#")]),e._v(" 最后")]),e._v(" "),s("p",[e._v("关于"),s("code",[e._v("useMemo")]),e._v("与"),s("code",[e._v("useCallback")]),e._v("是否值得尽量多用，私认为并不应该这么做，如果在性能优化方面非常有效，值得在每个依赖或者函数都值得使用"),s("code",[e._v("useMemo")]),e._v("与"),s("code",[e._v("useCallback")]),e._v("的话，"),s("code",[e._v("React")]),e._v("可以干脆将其作为默认的功能，又可以减少用户使用"),s("code",[e._v("Hooks")]),e._v("的心智负担，又可以减少使用"),s("code",[e._v("Hooks")]),e._v("的包裹让代码更加简洁，可是"),s("code",[e._v("React")]),e._v("并没有这么做，实际上这仍然是一个权衡的问题，权衡性能优化的点，取一个折衷，具体来说就是你需要评估你组件"),s("code",[e._v("re-render")]),e._v(" 的次数和代价，"),s("code",[e._v("React.memo")]),e._v("、"),s("code",[e._v("useMemo")]),e._v("与"),s("code",[e._v("useCallback")]),e._v("这些缓存机制也是有代价的，需要做好平衡，不能盲目的多用这类缓存优化方案，比起盲目的进行各种细微的优化，分析清楚性能问题出现的原因才能真正的解决问题。")]),e._v(" "),s("h2",{attrs:{id:"每日一题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#每日一题"}},[e._v("#")]),e._v(" 每日一题")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("https://github.com/WindrunnerMax/EveryDay\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("https://www.zhihu.com/question/428921970\nhttps://www.zhihu.com/question/390974405\nhttps://juejin.cn/post/6844904032113278990\nhttps://juejin.cn/post/6844904001998176263\nhttps://segmentfault.com/a/1190000039405417\nhttps://www.infoq.cn/article/mm5btiwipppnpjhjqgtr\nhttps://zh-hans.reactjs.org/docs/hooks-reference.html\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])])])}),[],!1,null,null,null);s.default=t.exports}}]);